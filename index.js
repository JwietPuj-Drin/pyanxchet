/* global Qieyun, kyonh, putonghua, gwongzau, kanon */

/*
const Qieyun = require('qieyun');
const { kyonh, putonghua, gwongzau } = require('qieyun-examples-node');
const readlineSync = require('readline-sync');
const { 預設上字小韻號, 預設下字小韻號 } = require('./test-utils');
*/

/* 1. 輔助工具 */

function noThrow(f) {
  return function inner(...args) {
    try {
      return f(...args);
    } catch (e) {
      return '暫無資料';
    }
  };
}

class StringLogger {
  constructor() {
    this.res = [];
  }

  log(...args) {
    this.res.push(args.join(' '));
  }

  tick() {
    this.res = [];
  }

  tock() {
    return this.res.join('\n');
  }
}

const logger = new StringLogger();

function 數字到漢語基數詞(n) {
  return ['零', '一', '兩', '三', '四', '五', '六', '七', '八', '九', '十', '十一'][n];
}

/* 2. 音韻學輔助工具 */

const 首小韻號 = 1;
const 末小韻號 = 3874;

function 符合的音韻地位(音韻描述字串) {
  const 要排除的重複小韻號 = new Set([
    133, 138, 210, 209, 552, 804, 902, 1002, 1097, 1191, 1281,
    1458, 1464, 1492, 1792, 1831, 1829, 1954, 2076, 2245, 2548,
    2452, 2470, 2527, 2607, 2849, 2855, 3152, 3181, 3321, 3339,
    3331, 3377, 3534, 3722, 3792, 3807, 3842,
  ]);
  const res = [];
  for (let 小韻號 = 首小韻號; 小韻號 <= 末小韻號; 小韻號++) {
    if (!要排除的重複小韻號.has(小韻號)) {
      const 音韻地位 = Qieyun.get音韻地位(小韻號);
      if (音韻地位.屬於(音韻描述字串)) {
        res.push(音韻地位);
      }
    }
  }
  return res;
}

function 格式化普通話拼音(s) {
  return s
    .replace(/([aeiou])(ng?|r)([1234])/u, '$1$3$2')
    .replace(/([aeo])([iuo])([1234])/u, '$1$3$2')
    .replace('a1', 'ā')
    .replace('a2', 'á')
    .replace('a3', 'ǎ')
    .replace('a4', 'à')
    .replace('e1', 'ē')
    .replace('e2', 'é')
    .replace('e3', 'ě')
    .replace('e4', 'è')
    .replace('o1', 'ō')
    .replace('o2', 'ó')
    .replace('o3', 'ǒ')
    .replace('o4', 'ò')
    .replace('i1', 'ī')
    .replace('i2', 'í')
    .replace('i3', 'ǐ')
    .replace('i4', 'ì')
    .replace('u1', 'ū')
    .replace('u2', 'ú')
    .replace('u3', 'ǔ')
    .replace('u4', 'ù')
    .replace('v1', 'ǖ')
    .replace('v2', 'ǘ')
    .replace('v3', 'ǚ')
    .replace('v4', 'ǜ')
    .replace('v', 'ü');
}

const 音韻描述2普通話拼音Map = new Map();

const 音韻描述2小韻名稱Map = new Map();

for (let 小韻號 = 末小韻號; 小韻號 >= 首小韻號; 小韻號--) {
  const 小韻名 = Qieyun.query小韻號(小韻號)[0][0];
  const { 音韻描述 } = Qieyun.get音韻地位(小韻號);
  const 普通話拼音 = 格式化普通話拼音(putonghua(小韻號));
  音韻描述2普通話拼音Map.set(音韻描述, 普通話拼音);
  音韻描述2小韻名稱Map.set(音韻描述, `${小韻號} ${小韻名}小韻`);
}

function 音韻描述2普通話拼音(s) {
  const res = 音韻描述2普通話拼音Map.get(s);
  return res == null || res === '?' ? '暫無資料' : res;
}

function 音韻描述2小韻名稱(s) {
  return 音韻描述2小韻名稱Map.get(s) || '不在廣韻中的小韻';
}

const 母對應的等 = {
  幫: ['一', '二', '三', '四'],
  滂: ['一', '二', '三', '四'],
  並: ['一', '二', '三', '四'],
  明: ['一', '二', '三', '四'],
  端: ['一', '四'],
  透: ['一', '四'],
  定: ['一', '四'],
  泥: ['一', '四'],
  來: ['一', '二', '三', '四'],
  知: ['二', '三'],
  徹: ['二', '三'],
  澄: ['二', '三'],
  孃: ['二', '三'],
  精: ['一', '三', '四'],
  清: ['一', '三', '四'],
  從: ['一', '三', '四'],
  心: ['一', '三', '四'],
  邪: ['一', '三', '四'],
  莊: ['二', '三'],
  初: ['二', '三'],
  崇: ['二', '三'],
  生: ['二', '三'],
  俟: ['二', '三'],
  章: ['三'],
  昌: ['三'],
  常: ['三'],
  書: ['三'],
  船: ['三'],
  日: ['三'],
  見: ['一', '二', '三', '四'],
  溪: ['一', '二', '三', '四'],
  羣: ['三'],
  疑: ['一', '二', '三', '四'],
  影: ['一', '二', '三', '四'],
  曉: ['一', '二', '三', '四'],
  匣: ['一', '二', '四'],
  云: ['三'],
  以: ['三'],
};

const 韻對應的開合 = {
  東: ['開'],
  冬: ['開'],
  鍾: ['開'],
  江: ['開'],
  支: ['開', '合'],
  脂: ['開', '合'],
  之: ['開'],
  微: ['開', '合'],
  模: ['開'],
  魚: ['開'],
  虞: ['合'],
  泰: ['開', '合'],
  咍: ['開'],
  灰: ['合'],
  佳: ['開', '合'],
  皆: ['開', '合'],
  夬: ['開', '合'],
  祭: ['開', '合'],
  廢: ['開', '合'],
  齊: ['開', '合'],
  痕: ['開'],
  魂: ['合'],
  眞: ['開', '合'],
  臻: ['開'],
  欣: ['開'],
  元: ['開', '合'],
  諄: ['合'],
  文: ['合'],
  寒: ['開'],
  桓: ['合'],
  刪: ['開', '合'],
  山: ['開', '合'],
  仙: ['開', '合'],
  先: ['開', '合'],
  豪: ['開'],
  肴: ['開'],
  宵: ['開'],
  蕭: ['開'],
  歌: ['開'],
  戈: ['開', '合'],
  麻: ['開', '合'],
  唐: ['開', '合'],
  陽: ['開', '合'],
  庚: ['開', '合'],
  耕: ['開', '合'],
  清: ['開', '合'],
  青: ['開', '合'],
  登: ['開', '合'],
  蒸: ['開', '合'],
  侯: ['開'],
  尤: ['開'],
  幽: ['開'],
  侵: ['開'],
  覃: ['開'],
  談: ['開'],
  咸: ['開'],
  銜: ['開'],
  鹽: ['開'],
  嚴: ['開'],
  凡: ['合'],
  添: ['開'],
};

const 韻對應的等 = {
  東: ['一', '三'],
  冬: ['一'],
  鍾: ['三'],
  江: ['二'],
  支: ['三'],
  脂: ['三'],
  之: ['三'],
  微: ['三'],
  模: ['一'],
  魚: ['三'],
  虞: ['三'],
  泰: ['一'],
  咍: ['一'],
  灰: ['一'],
  佳: ['二'],
  皆: ['二'],
  夬: ['二'],
  祭: ['三'],
  廢: ['三'],
  齊: ['四'],
  痕: ['一'],
  魂: ['一'],
  眞: ['三'],
  臻: ['三'],
  欣: ['三'],
  元: ['三'],
  諄: ['三'],
  文: ['三'],
  寒: ['一'],
  桓: ['一'],
  刪: ['二'],
  山: ['二'],
  仙: ['三'],
  先: ['四'],
  豪: ['一'],
  肴: ['二'],
  宵: ['三'],
  蕭: ['四'],
  歌: ['一'],
  戈: ['一', '三'],
  麻: ['二', '三'],
  唐: ['一'],
  陽: ['三'],
  庚: ['二', '三'],
  耕: ['二'],
  清: ['三'],
  青: ['四'],
  登: ['一'],
  蒸: ['三'],
  侯: ['一'],
  尤: ['三'],
  幽: ['三'],
  侵: ['三'],
  覃: ['一'],
  談: ['一'],
  咸: ['二'],
  銜: ['二'],
  鹽: ['三'],
  嚴: ['三'],
  凡: ['三'],
  添: ['四'],
};

const 脣音的韻與等到開合 = {
  東一: '開',
  東三: '開',
  冬一: '開',
  鍾三: '開',
  江二: '開',
  支三: '開',
  脂三: '開',
  微三: '合',
  虞三: '合',
  模一: '開',
  齊四: '開',
  祭三: '開',
  泰一: '開',
  佳二: '開',
  皆二: '開',
  夬二: '開',
  灰一: '合',
  咍一: '開',
  廢三: '合',
  眞三: '開',
  文三: '合',
  元三: '合',
  魂一: '合',
  寒一: '開',
  桓一: '合',
  刪二: '開',
  山二: '開',
  仙三: '開',
  先四: '開',
  宵三: '開',
  肴二: '開',
  豪一: '開',
  歌一: '開',
  戈一: '合',
  麻二: '開',
  麻三: '開',
  陽三: '合',
  唐一: '開',
  庚二: '開',
  庚三: '開',
  耕二: '開',
  清三: '開',
  青四: '開',
  蒸三: '開',
  登一: '開',
  尤三: '開',
  侯一: '開',
  幽三: '開',
  侵三: '開',
  談一: '開',
  鹽三: '開',
  添四: '開',
  銜二: '開',
  凡三: '合',
};

function 是重紐韻(韻) {
  return [...'支脂祭眞諄仙宵侵鹽清'].includes(韻);
}

function 是重紐母(母) {
  return [...'幫滂並明見溪羣疑影曉'].includes(母);
}

/* 3. 反切規則 */

function 定等(被切字母, 被切字韻, 上字音韻地位, 下字音韻地位) {
  const 母對應的被切字等 = 母對應的等[被切字母];
  const 韻對應的被切字等 = 韻對應的等[被切字韻];

  if (母對應的被切字等.length === 1) {
    logger.log(`${被切字母}母只可能是${母對應的被切字等[0]}等`);
  } else {
    logger.log(`${被切字母}母可能是${母對應的被切字等.join('、')}等`);
  }

  if (韻對應的被切字等.length === 1) {
    logger.log(`${被切字韻}韻只可能是${韻對應的被切字等[0]}等`);
  } else {
    logger.log(`${被切字韻}韻可能是${韻對應的被切字等.join('、')}等`);
  }

  let 可能的被切字等 = [...母對應的被切字等].filter((x) => 韻對應的被切字等.includes(x));

  // 母對應的等與韻對應的等不匹配，矛盾
  if (可能的被切字等.length === 0) {
    throw new Error('矛盾，故為不合法音節');
  }

  // 由母和韻共同定等
  if (可能的被切字等.length === 1) {
    logger.log(`綜合可知，被切字只可能是${可能的被切字等[0]}等`);
    return 可能的被切字等[0];
  }

  // 由上下字定等
  const 上字是三等 = 上字音韻地位.等 === '三';
  const 下字是三等 = 下字音韻地位.等 === '三';

  // 下字為三等，被切字為三等
  if (下字是三等) {
    logger.log('下字為三等，故被切字為三等');
    return '三';
  }

  // 上下字均非三等，被切字為非三等
  if (!上字是三等 && !下字是三等) {
    可能的被切字等 = 可能的被切字等.filter((等) => 等 !== '三');
    if (可能的被切字等.length === 1) {
      logger.log('上下字均為非三等，故被切字為非三等');
      logger.log(`綜合可知，被切字只可能是${可能的被切字等[0]}等`);
      return 可能的被切字等[0];
    }
  }

  logger.log(`上字為${上字音韻地位.等}等，下字為${下字音韻地位.等}等`);
  logger.log('無法根據規則判斷被切字等');
  return '無法判斷';
}

function 定開合(被切字母, 被切字韻, 被切字等, 上字音韻地位, 下字音韻地位) {
  // 脣音不分開合
  const 被切字是幫組 = [...'幫滂並明'].includes(被切字母);

  if (被切字是幫組) {
    const res = 脣音的韻與等到開合[被切字韻 + 被切字等];
    if (res != null) {
      logger.log('被切字屬幫組，不分開合');
      logger.log(`但根據韻典定義，幫組${被切字韻}韻${被切字等}等是${res}口`);
      return res;
    }
  }

  // 韻定開合
  const 可能的被切字開合 = 韻對應的開合[被切字韻];

  if (可能的被切字開合.length === 1) {
    logger.log(`${被切字韻}韻只可能是${可能的被切字開合[0]}口`);
    return 可能的被切字開合[0];
  }

  // 上下字定開合
  const 上字是開口 = 上字音韻地位.開合 === '開' && !上字音韻地位.屬於('幫組 或 模韻');
  const 下字是開口 = 下字音韻地位.開合 === '開' && !下字音韻地位.屬於('幫組 或 模韻');

  const 上字是合口 = 上字音韻地位.開合 === '合' && !上字音韻地位.屬於('幫組 或 模韻');
  const 下字是合口 = 下字音韻地位.開合 === '合' && !下字音韻地位.屬於('幫組 或 模韻');

  const 上字是模韻 = 上字音韻地位.屬於('模韻');
  const 下字是幫組 = 下字音韻地位.屬於('幫組');

  // 能確定開合的情況
  if (上字是開口 && 下字是開口) {
    logger.log('反切上下字均為開口，故被切字為開口');
    return '開';
  }
  if (下字是合口) {
    logger.log('下字為合口，故被切字為合口');
    return '合';
  }
  if (上字是合口 && 下字是幫組) {
    logger.log('上字為合口，下字為幫組，故被切字為合口');
    return '合';
  }

  // 不能確定開合的情況
  if (上字是模韻 && 下字是開口) {
    logger.log('上字為模韻，下字為開口，被切字可能為開口或合口');
    return '無法判斷';
  }
  if (上字是開口 && 下字是幫組) {
    logger.log('上字為開口，下字為幫組，被切字可能為開口或合口');
    return '無法判斷';
  }
  if (上字是合口 && 下字是開口) {
    logger.log('上字為合口，下字為開口，被切字可能為開口或合口');
    return '無法判斷';
  }
  if (上字是模韻 && 下字是幫組) {
    logger.log('上字為模韻，下字為幫組，被切字可能為開口或合口');
    return '無法判斷';
  }

  // 其他情況（不會出現，因上面規則已經覆蓋所有情況）
  return '無法判斷';
}

function 定重紐(被切字母, 被切字韻, 下字音韻地位, 上字音韻地位) {
  if (!是重紐母(被切字母)) {
    logger.log(`${被切字母}母沒有重紐對立，故無須確定重紐`);
    return null;
  }
  if (!是重紐韻(被切字韻)) {
    logger.log(`${被切字韻}韻沒有重紐對立，故無須確定重紐`);
    return null;
  }
  if (上字音韻地位.重紐 === 'B') {
    logger.log('上字屬重紐B類，被切字為重紐B類');
    return 'B';
  }
  if (上字音韻地位.重紐 === 'A') {
    logger.log('上字屬重紐A類，被切字為重紐A類');
    return 'A';
  }
  if (下字音韻地位.重紐 === 'B') {
    logger.log('下字屬重紐B類，被切字為重紐B類');
    return 'B';
  }
  if (下字音韻地位.屬於('云母')) {
    logger.log('下字屬云母，被切字為重紐B類');
    return 'B';
  }
  if (下字音韻地位.重紐 === 'A') {
    logger.log('下字屬重紐A類，被切字為重紐A類');
    return 'A';
  }
  if (下字音韻地位.屬於('精組 或 以母')) {
    logger.log('下字屬精組、以母，被切字為重紐A類');
    return 'A';
  }
  logger.log('無法根據規則判斷被切字重紐');
  return '無法判斷';
}

/* 4. 執行反切 */

function 開始反切(上字音韻地位, 下字音韻地位) {
  const 上字母 = 上字音韻地位.母;
  const 下字韻 = 下字音韻地位.韻賅上去入;
  const 下字聲 = 下字音韻地位.聲;

  // 定被切字母、韻、聲
  const 被切字母 = 上字母;
  logger.log(`上字屬${上字母}母，故被切字屬${被切字母}母`);
  const 被切字韻 = 下字韻;
  logger.log(`下字屬${下字韻}韻，故被切字屬${被切字韻}韻`);
  const 被切字聲 = 下字聲;
  logger.log(`下字屬${下字聲}聲，故被切字屬${被切字聲}聲`);

  // 定被切字等
  const 被切字等 = 定等(被切字母, 被切字韻, 上字音韻地位, 下字音韻地位);

  // 定被切字開合
  const 被切字開合 = 定開合(被切字母, 被切字韻, 被切字等, 上字音韻地位, 下字音韻地位);

  // 定被切字重紐
  const 被切字重紐 = 定重紐(被切字母, 被切字韻, 下字音韻地位, 上字音韻地位);

  if ([被切字等, 被切字開合, 被切字重紐].includes('無法判斷')) {
    // 窮舉法
    const 母1 = `${被切字母}母`;
    const 韻1 = `${被切字韻}韻`;
    const 聲1 = `${被切字聲}聲`;

    const 等1 = 被切字等 === '無法判斷' ? null : `${被切字等}等`;
    const 開合1 = 被切字開合 === '無法判斷' ? null : `${被切字開合}口`;
    const 重紐1 = 被切字重紐 === '無法判斷' || 被切字重紐 == null ? null : `重紐${被切字重紐}類`;

    const 音韻描述字串 = [母1, 開合1, 等1, 重紐1, 韻1, 聲1].filter((x) => x != null).join(' ');
    const 所有符合的音韻地位 = 符合的音韻地位(音韻描述字串);

    if (所有符合的音韻地位.length > 0) {
      logger.log('使用窮舉法判斷未確定的屬性');
      logger.log(`經窮舉廣韻所有小韻，發現${數字到漢語基數詞(所有符合的音韻地位.length)}個小韻滿足條件`);
      return 所有符合的音韻地位;
    }

    // 排列組合被切字開合
    if (被切字開合 === '無法判斷' && 被切字等 !== '無法判斷' && 被切字重紐 !== '無法判斷') {
      return [
        new Qieyun.音韻地位(被切字母, '開', 被切字等, 被切字重紐, 被切字韻, 被切字聲),
        new Qieyun.音韻地位(被切字母, '合', 被切字等, 被切字重紐, 被切字韻, 被切字聲),
      ];
    }

    // 排列組合被切字重紐
    if (被切字開合 !== '無法判斷' && 被切字等 !== '無法判斷' && 被切字重紐 === '無法判斷') {
      return [
        new Qieyun.音韻地位(被切字母, 被切字開合, 被切字等, 'A', 被切字韻, 被切字聲),
        new Qieyun.音韻地位(被切字母, 被切字開合, 被切字等, 'B', 被切字韻, 被切字聲),
      ];
    }

    throw new Error('無法判斷');
  }

  return [new Qieyun.音韻地位(被切字母, 被切字開合, 被切字等, 被切字重紐, 被切字韻, 被切字聲)];
}

function 切(上字, 下字, 上字音韻地位, 下字音韻地位) {
  logger.tick();

  logger.log(`${上字}的音韻地位為: ${上字音韻地位.音韻描述}`);
  logger.log(`${上字}字屬:`, 音韻描述2小韻名稱(上字音韻地位.音韻描述));
  logger.log(`${上字}的古韻羅馬字為:`, kyonh(上字音韻地位));
  logger.log(`${上字}的推導普通話為:`, 音韻描述2普通話拼音(上字音韻地位.音韻描述));
  logger.log(`${上字}的推導廣州音為:`, gwongzau(上字音韻地位));
  logger.log(`${上字}的推導日語漢音為:`, kanon(上字音韻地位));
  logger.log();

  logger.log(`${下字}的音韻地位為: ${下字音韻地位.音韻描述}`);
  logger.log(`${下字}字屬:`, 音韻描述2小韻名稱(下字音韻地位.音韻描述));
  logger.log(`${下字}的古韻羅馬字為:`, kyonh(下字音韻地位));
  logger.log(`${下字}的推導普通話為:`, 音韻描述2普通話拼音(下字音韻地位.音韻描述));
  logger.log(`${下字}的推導廣州音為:`, gwongzau(下字音韻地位));
  logger.log(`${下字}的推導日語漢音為:`, kanon(下字音韻地位));
  logger.log();

  let 被切字音韻地位們;
  try {
    被切字音韻地位們 = 開始反切(上字音韻地位, 下字音韻地位);
    logger.log();
  } catch (err) {
    logger.log(err.message);
    return logger.tock();
  }

  for (const 被切字音韻地位 of 被切字音韻地位們) {
    logger.log(`被切字的音韻地位為: ${被切字音韻地位.音韻描述}`);
    logger.log('被切字屬:', 音韻描述2小韻名稱(被切字音韻地位.音韻描述));
    logger.log('被切字的古韻羅馬字為:', noThrow(kyonh)(被切字音韻地位));
    logger.log('被切字的推導普通話為:', 音韻描述2普通話拼音(被切字音韻地位.音韻描述));
    logger.log('被切字的推導廣州音為:', noThrow(gwongzau)(被切字音韻地位));
    logger.log('被切字的推導日語漢音為:', noThrow(kanon)(被切字音韻地位));
    logger.log();
  }

  return logger.tock();
}

/* 5. 與用户交互 */

function 觸發反切() {
  const 反切 = document.getElementById('反切輸入').value;
  if ([...反切].length !== 2) return; // 若長度不為 2，略過
  if (/[0-9a-zA-Z]/g.test(反切)) return; // 若含有英文字母或數字，略過

  const [上字, 下字] = [...反切];

  try {
    提供多音字選擇(上字, document.getElementById('上字讀音'));
    提供多音字選擇(下字, document.getElementById('下字讀音'));
  } catch (e) {
    document.getElementById('結果').value = e.message;
    return;
  }

  處理多音字選擇();
}

function 提供多音字選擇(漢字, 目標標籤) {
  目標標籤.innerHTML = '';

  const items = Qieyun.query漢字(漢字);
  const fragment = document.createDocumentFragment();

  for (const { 小韻號 } of items) {
    const option = document.createElement('option');
    option.value = 小韻號;
    option.innerText = Qieyun.get音韻地位(小韻號).音韻描述;
    fragment.appendChild(option);
  }

  if (items.length === 0) {
    throw Error(`無${漢字}字讀音`);
  }

  目標標籤.disabled = items.length === 1; // 若長度為 1，則無需選擇
  目標標籤.appendChild(fragment);
}

function 處理多音字選擇() {
  const 反切 = document.getElementById('反切輸入').value;
  const [上字, 下字] = [...反切];

  const 上字小韻號 = parseInt(document.getElementById('上字讀音').value, 10);
  const 下字小韻號 = parseInt(document.getElementById('下字讀音').value, 10);

  if (上字小韻號 === 0) throw Error('無上字讀音');
  if (下字小韻號 === 0) throw Error('無下字讀音');

  const 反切上字音韻地位 = Qieyun.get音韻地位(上字小韻號);
  const 反切下字音韻地位 = Qieyun.get音韻地位(下字小韻號);

  const result = 切(上字, 下字, 反切上字音韻地位, 反切下字音韻地位);

  document.getElementById('結果').innerText = result;
}

/* 6. 測試（在 Node.js 環境中運行） */

/*
function test() {
  for (let 小韻號 = 首小韻號; 小韻號 <= 末小韻號; 小韻號++) {
    const 上字 = Qieyun.get上字(小韻號);
    const 下字 = Qieyun.get下字(小韻號);

    if (上字 == null) continue; // 沒有反切的小韻

    const 反切 = `${上字}${下字}切`;
    const 實際被切字音韻地位 = Qieyun.get音韻地位(小韻號);

    try {
      const 上字音韻地位 = Qieyun.get音韻地位(預設上字小韻號[上字] || Qieyun.query漢字(上字)[0]['小韻號']);
      const 下字音韻地位 = Qieyun.get音韻地位(預設下字小韻號[下字] || Qieyun.query漢字(下字)[0]['小韻號']);
      try {
        const 預測被切字音韻地位 = 開始反切(上字音韻地位, 下字音韻地位)[0];
        if (實際被切字音韻地位.音韻描述 !== 預測被切字音韻地位.音韻描述) {
          console.error(小韻號, 反切, 上字音韻地位.音韻描述, 下字音韻地位.音韻描述, 實際被切字音韻地位.音韻描述, 預測被切字音韻地位.音韻描述);
        }
      } catch (err) {
        const s = err.message;
        console.error(小韻號, 反切, 上字音韻地位.音韻描述, 下字音韻地位.音韻描述, 實際被切字音韻地位.音韻描述, s);
      }
    } catch (err) {
      const s = err.message;
      console.error(小韻號, 反切, 實際被切字音韻地位.音韻描述, s);
    }
  }
}

test();
*/
